% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/set_syntenyParams.R
\name{set_syntenyParams}
\alias{set_syntenyParams}
\alias{annotate_bed}
\alias{annotate_blast}
\title{Set synteny parameters and parse required data}
\usage{
set_syntenyParams(
  gsParam,
  overwrite = FALSE,
  verbose = TRUE,
  plotSize = 8,
  dotsPerIn = 64,
  makePlots = TRUE
)

annotate_bed(gsParam)

annotate_blast(gsParam)
}
\arguments{
\item{gsParam}{A list of genespace parameters. This should be created
by init_genespace.}

\item{overwrite}{logical, should the combBed.txt and synHits be re-generated
if they exist. Default is FALSE.}

\item{verbose}{logical, should updates be printed to the console?

\cr
If called, \code{set_syntenyParams} returns its own arguments.}
}
\description{
\code{set_syntenyParams} Generate all data needed to run synteny. This
includes the synteny parameters, combined/annotated bed file and annotated
blast files.

\code{set_syntenyParams} set_syntenyParams

\code{annotate_bed} annotate_bed

\code{annotate_blast} annotate_blast
}
\details{
set_synParam can be called directly to generate all data needed to
run synteny. This MUST be run before synteny, to ensure that all data are
in the right format and ready to go. The first step follows the functionality
in < v1, generating a matrix of query v. target genomes and populates that
with all needed parameters. The second step follows what was `annotate_gff`
in < v1, and is now called `annotate_bed`. In each case, this function
(detailed below) is designed to be used internally, but can be called by the
user if desired. The third step follows the first step of `synteny` in < v1,
where the blast files are read in and populated with the required positional
etc. info from the combined bed file. This functionality is also offered as
an exported function `annotate_blast`, but should just be called within
`set_syntenyParam`.

The combined bed file is annotated with a variety of additional
information. These data are required for synteny and pangenome functions. The
biggest steps are 1) finding physically dispersed orthogroups (those which
hit lots of places across the genome) and flagging these so they won't be
used in synteny detection, 2) determining whether you should use phylo.
hierarchical orthogroups (HOGs) or the traditional orthogroup.tsv (OGs)
methods, and 3) determining membership and representatives of tandem arrays,
which here are defined as physically proximate orthogroup members. The
function is verbose and prints several sets of data that may be useful to
contextualize your run and ensure that you are using sufficiently high
quality genomes and annotations.

The combined bed file contains the first four bed columns (chr, start, end,
name), and the following (columns 4:16):
\enumerate{
\item genome unique genomeID, taken from the individual bed files
\item ord integer with the order of genes
\item unique orthofinder ID, taken from 'SequenceIDs.txt'
\item pepLen: amino acid length of the gene CDS
\item arrayID: tandem array ID, unique for each genome, og and chr.
\item isArayRep: logical flag whether a gene is the representative for array
\item globOG: global orthogroup id (from 'Orthogroups.tsv')
\item globHOG: global phylogenetically hierarchical orthogroup id (N0.tsv)
\item synOG: og, split by synteny
\item inblkOG: synOG, merged across within-block orthogroups
\item noAnchor: logical flag whether this gene can ever be a syntenic anchor
\item og: either globOG or globHOG, depending on if useHOG = FALSE or TRUE
}
}
